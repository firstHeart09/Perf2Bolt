1. lastest_getprofile.sh  该文件是最终的脚本文件，可以完成信息的提取并输出到perf.fdata文件中
				注意：该文件在解析过程中和bolt源码的逻辑一致，但是在最后的写入到perf.fdata时，即
				调用readProfile函数时，没有按照bolt的源码逻辑写
				在这里的逻辑是：因为前面已经得到了from与to的trace信息，然后我们找每个trace的第一个大于该地址（指的是form和to的地址）
				的前一个函数的信息，然后将其按照bolt源码中关于perf.fdata的数据格式写入到perf.fdata文件中
2. new_getprofile.sh  正在迭代更新的版本
3. after_parse_begin_readprofile.sh  该版本是提取完信息的版本，即在bolt源码中调用readProfile函数之前的版本
4. run.sh  该脚本用于运行上述脚本
5. objdump.sh  该脚本用于从可执行文件中提取函数信息，该脚本内容已经集成到1 2 3中
6. readelf.sh  该脚本用于从可执行文件中提取段信息、符号信息并做处理，该脚本已经集成到1 2 3中



现在还存在的问题
1. 因为该shell脚本处理的perf命令生成的分支数据非常大，所以处理该分支数据需要较长的时间。如一个branch的文件共计145万行，每行至少32个数据，整个文件共计4500万行需要处理的数据
2. 该shell脚本直至输出到最终的文件之前，都是按照bolt的源码架构编写。但是在将处理完成的数据写入到文件的时候没有按照bolt源码逻辑（bolt源码架构中关于这部分，需要基本块的信息。
	在我的shell脚本中并没有实现基本块信息的获取），所以导致最终的结果与bolt的工具perf2bolt运行结果不同
3. 因为目前的测试程序只有一个进程，所以不能够确定解析task事件这部分代码是否完全正确




我的shell脚本中最后输出的处理逻辑如下：
1. shell脚本处理完分支信息获取到的trace数据（from, to, takencount, mispred）。通过遍历函数信息（该函数按照函数地址从小到大排序），找到包含form的函数信息，通过from
	对应的地址信息减去函数的地址，获取到输出文件的偏移量；对于to做同样的处理
